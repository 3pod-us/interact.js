import test from '@interactjs/_dev/test/test';
import finder from './interactionFinder';
import * as helpers from './tests/_helpers';
test('modifiers/snap', t => {
    const { interactable, event, coords, scope, } = helpers.testEnv();
    const { body } = scope.document;
    const { list } = scope.interactions;
    const details = {
        pointer: event,
        get pointerId() { return details.pointer.pointerId; },
        get pointerType() { return details.pointer.pointerType; },
        eventType: null,
        eventTarget: body,
        curEventTarget: scope.document,
        scope,
    };
    scope.interactions.new({ pointerType: 'touch' });
    scope.interactions.new({ pointerType: 'mouse' });
    coords.pointerType = 'mouse';
    list[0].pointerType = 'mouse';
    list[2]._interacting = true;
    t.equal(list.indexOf(finder.search(details)), 2, '[pointerType: mouse] skips inactive mouse and touch interaction');
    list[2]._interacting = false;
    t.equal(list.indexOf(finder.search(details)), 0, '[pointerType: mouse] returns first idle mouse interaction');
    coords.pointerId = 4;
    list[1].pointerDown({ ...event }, { ...event }, body);
    coords.pointerType = 'touch';
    t.equal(list.indexOf(finder.search(details)), 1, '[pointerType: touch] gets interaction with pointerId');
    coords.pointerId = 5;
    t.equal(list.indexOf(finder.search(details)), 1, `[pointerType: touch] returns idle touch interaction without matching pointerId
    and existing touch interaction has pointer and no target`);
    interactable.options.gesture = { enabled: false };
    list[1].interactable = interactable;
    t.equal(list.indexOf(finder.search(details)), -1, `[pointerType: touch] no result without matching pointerId
    and existing touch interaction has a pointer and target not gesturable`);
    interactable.options.gesture = { enabled: true };
    t.equal(list.indexOf(finder.search(details)), 1, `[pointerType: touch] returns idle touch interaction with gesturable target
    and existing pointer`);
    t.end();
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJhY3Rpb25GaW5kZXIuc3BlYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImludGVyYWN0aW9uRmluZGVyLnNwZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxJQUFJLE1BQU0sNEJBQTRCLENBQUE7QUFDN0MsT0FBTyxNQUFNLE1BQU0scUJBQXFCLENBQUE7QUFDeEMsT0FBTyxLQUFLLE9BQU8sTUFBTSxrQkFBa0IsQ0FBQTtBQUUzQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDLEVBQUU7SUFDekIsTUFBTSxFQUNKLFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxFQUNOLEtBQUssR0FDTixHQUFHLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQTtJQUVyQixNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQTtJQUUvQixNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDLFlBQVksQ0FBQTtJQUNuQyxNQUFNLE9BQU8sR0FBRztRQUNkLE9BQU8sRUFBRSxLQUFLO1FBQ2QsSUFBSSxTQUFTLEtBQU0sT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQSxDQUFDLENBQUM7UUFDckQsSUFBSSxXQUFXLEtBQU0sT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQSxDQUFDLENBQUM7UUFDekQsU0FBUyxFQUFFLElBQUk7UUFDZixXQUFXLEVBQUUsSUFBSTtRQUNqQixjQUFjLEVBQUUsS0FBSyxDQUFDLFFBQVE7UUFDOUIsS0FBSztLQUNOLENBQUE7SUFFRCxLQUFLLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFBO0lBQ2hELEtBQUssQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUE7SUFFaEQsTUFBTSxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUE7SUFDNUIsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUE7SUFDN0IsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUE7SUFFM0IsQ0FBQyxDQUFDLEtBQUssQ0FDTCxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsRUFDcEMsQ0FBQyxFQUNELGlFQUFpRSxDQUNsRSxDQUFBO0lBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUE7SUFFNUIsQ0FBQyxDQUFDLEtBQUssQ0FDTCxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsRUFDcEMsQ0FBQyxFQUNELDJEQUEyRCxDQUM1RCxDQUFBO0lBRUQsTUFBTSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUE7SUFDcEIsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxFQUFFLEdBQUcsS0FBSyxFQUFTLEVBQUUsRUFBRSxHQUFHLEtBQUssRUFBUyxFQUFFLElBQUksQ0FBQyxDQUFBO0lBQ25FLE1BQU0sQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFBO0lBRTVCLENBQUMsQ0FBQyxLQUFLLENBQ0wsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQ3BDLENBQUMsRUFDRCxzREFBc0QsQ0FDdkQsQ0FBQTtJQUVELE1BQU0sQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFBO0lBRXBCLENBQUMsQ0FBQyxLQUFLLENBQ0wsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQ3BDLENBQUMsRUFDRDs2REFDeUQsQ0FDMUQsQ0FBQTtJQUVELFlBQVksQ0FBQyxPQUFPLENBQUMsT0FBTyxHQUFHLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxDQUFBO0lBQ2pELElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFBO0lBRW5DLENBQUMsQ0FBQyxLQUFLLENBQ0wsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQ3BDLENBQUMsQ0FBQyxFQUNGOzJFQUN1RSxDQUN4RSxDQUFBO0lBRUQsWUFBWSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEdBQUcsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUE7SUFFaEQsQ0FBQyxDQUFDLEtBQUssQ0FDTCxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsRUFDcEMsQ0FBQyxFQUNEO3lCQUNxQixDQUN0QixDQUFBO0lBRUQsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFBO0FBQ1QsQ0FBQyxDQUFDLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdGVzdCBmcm9tICdAaW50ZXJhY3Rqcy9fZGV2L3Rlc3QvdGVzdCdcbmltcG9ydCBmaW5kZXIgZnJvbSAnLi9pbnRlcmFjdGlvbkZpbmRlcidcbmltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi90ZXN0cy9faGVscGVycydcblxudGVzdCgnbW9kaWZpZXJzL3NuYXAnLCB0ID0+IHtcbiAgY29uc3Qge1xuICAgIGludGVyYWN0YWJsZSxcbiAgICBldmVudCxcbiAgICBjb29yZHMsXG4gICAgc2NvcGUsXG4gIH0gPSBoZWxwZXJzLnRlc3RFbnYoKVxuXG4gIGNvbnN0IHsgYm9keSB9ID0gc2NvcGUuZG9jdW1lbnRcblxuICBjb25zdCB7IGxpc3QgfSA9IHNjb3BlLmludGVyYWN0aW9uc1xuICBjb25zdCBkZXRhaWxzID0ge1xuICAgIHBvaW50ZXI6IGV2ZW50LFxuICAgIGdldCBwb2ludGVySWQgKCkgeyByZXR1cm4gZGV0YWlscy5wb2ludGVyLnBvaW50ZXJJZCB9LFxuICAgIGdldCBwb2ludGVyVHlwZSAoKSB7IHJldHVybiBkZXRhaWxzLnBvaW50ZXIucG9pbnRlclR5cGUgfSxcbiAgICBldmVudFR5cGU6IG51bGwsXG4gICAgZXZlbnRUYXJnZXQ6IGJvZHksXG4gICAgY3VyRXZlbnRUYXJnZXQ6IHNjb3BlLmRvY3VtZW50LFxuICAgIHNjb3BlLFxuICB9XG5cbiAgc2NvcGUuaW50ZXJhY3Rpb25zLm5ldyh7IHBvaW50ZXJUeXBlOiAndG91Y2gnIH0pXG4gIHNjb3BlLmludGVyYWN0aW9ucy5uZXcoeyBwb2ludGVyVHlwZTogJ21vdXNlJyB9KVxuXG4gIGNvb3Jkcy5wb2ludGVyVHlwZSA9ICdtb3VzZSdcbiAgbGlzdFswXS5wb2ludGVyVHlwZSA9ICdtb3VzZSdcbiAgbGlzdFsyXS5faW50ZXJhY3RpbmcgPSB0cnVlXG5cbiAgdC5lcXVhbChcbiAgICBsaXN0LmluZGV4T2YoZmluZGVyLnNlYXJjaChkZXRhaWxzKSksXG4gICAgMixcbiAgICAnW3BvaW50ZXJUeXBlOiBtb3VzZV0gc2tpcHMgaW5hY3RpdmUgbW91c2UgYW5kIHRvdWNoIGludGVyYWN0aW9uJ1xuICApXG5cbiAgbGlzdFsyXS5faW50ZXJhY3RpbmcgPSBmYWxzZVxuXG4gIHQuZXF1YWwoXG4gICAgbGlzdC5pbmRleE9mKGZpbmRlci5zZWFyY2goZGV0YWlscykpLFxuICAgIDAsXG4gICAgJ1twb2ludGVyVHlwZTogbW91c2VdIHJldHVybnMgZmlyc3QgaWRsZSBtb3VzZSBpbnRlcmFjdGlvbidcbiAgKVxuXG4gIGNvb3Jkcy5wb2ludGVySWQgPSA0XG4gIGxpc3RbMV0ucG9pbnRlckRvd24oeyAuLi5ldmVudCB9IGFzIGFueSwgeyAuLi5ldmVudCB9IGFzIGFueSwgYm9keSlcbiAgY29vcmRzLnBvaW50ZXJUeXBlID0gJ3RvdWNoJ1xuXG4gIHQuZXF1YWwoXG4gICAgbGlzdC5pbmRleE9mKGZpbmRlci5zZWFyY2goZGV0YWlscykpLFxuICAgIDEsXG4gICAgJ1twb2ludGVyVHlwZTogdG91Y2hdIGdldHMgaW50ZXJhY3Rpb24gd2l0aCBwb2ludGVySWQnXG4gIClcblxuICBjb29yZHMucG9pbnRlcklkID0gNVxuXG4gIHQuZXF1YWwoXG4gICAgbGlzdC5pbmRleE9mKGZpbmRlci5zZWFyY2goZGV0YWlscykpLFxuICAgIDEsXG4gICAgYFtwb2ludGVyVHlwZTogdG91Y2hdIHJldHVybnMgaWRsZSB0b3VjaCBpbnRlcmFjdGlvbiB3aXRob3V0IG1hdGNoaW5nIHBvaW50ZXJJZFxuICAgIGFuZCBleGlzdGluZyB0b3VjaCBpbnRlcmFjdGlvbiBoYXMgcG9pbnRlciBhbmQgbm8gdGFyZ2V0YFxuICApXG5cbiAgaW50ZXJhY3RhYmxlLm9wdGlvbnMuZ2VzdHVyZSA9IHsgZW5hYmxlZDogZmFsc2UgfVxuICBsaXN0WzFdLmludGVyYWN0YWJsZSA9IGludGVyYWN0YWJsZVxuXG4gIHQuZXF1YWwoXG4gICAgbGlzdC5pbmRleE9mKGZpbmRlci5zZWFyY2goZGV0YWlscykpLFxuICAgIC0xLFxuICAgIGBbcG9pbnRlclR5cGU6IHRvdWNoXSBubyByZXN1bHQgd2l0aG91dCBtYXRjaGluZyBwb2ludGVySWRcbiAgICBhbmQgZXhpc3RpbmcgdG91Y2ggaW50ZXJhY3Rpb24gaGFzIGEgcG9pbnRlciBhbmQgdGFyZ2V0IG5vdCBnZXN0dXJhYmxlYFxuICApXG5cbiAgaW50ZXJhY3RhYmxlLm9wdGlvbnMuZ2VzdHVyZSA9IHsgZW5hYmxlZDogdHJ1ZSB9XG5cbiAgdC5lcXVhbChcbiAgICBsaXN0LmluZGV4T2YoZmluZGVyLnNlYXJjaChkZXRhaWxzKSksXG4gICAgMSxcbiAgICBgW3BvaW50ZXJUeXBlOiB0b3VjaF0gcmV0dXJucyBpZGxlIHRvdWNoIGludGVyYWN0aW9uIHdpdGggZ2VzdHVyYWJsZSB0YXJnZXRcbiAgICBhbmQgZXhpc3RpbmcgcG9pbnRlcmBcbiAgKVxuXG4gIHQuZW5kKClcbn0pXG4iXX0=