// This module allows snapping of the size of targets during resize
// interactions.
import extend from '@interactjs/utils/extend';
import * as is from '@interactjs/utils/is';
import snap from './pointer';
function start(arg) {
    const { interaction, state } = arg;
    const { options } = state;
    const edges = interaction.prepared.edges;
    if (!edges) {
        return null;
    }
    arg.state = {
        options: {
            relativePoints: [{
                    x: edges.left ? 0 : 1,
                    y: edges.top ? 0 : 1,
                }],
            origin: { x: 0, y: 0 },
            offset: options.offset || 'self',
            range: options.range,
        },
    };
    state.targetFields = state.targetFields || [
        ['width', 'height'],
        ['x', 'y'],
    ];
    snap.start(arg);
    state.offsets = arg.state.offsets;
    arg.state = state;
}
function set(arg) {
    const { interaction, state, coords } = arg;
    const { options, offsets } = state;
    const relative = {
        x: coords.x - offsets[0].x,
        y: coords.y - offsets[0].y,
    };
    state.options = extend({}, options);
    state.options.targets = [];
    for (const snapTarget of (options.targets || [])) {
        let target;
        if (is.func(snapTarget)) {
            target = snapTarget(relative.x, relative.y, interaction);
        }
        else {
            target = snapTarget;
        }
        if (!target) {
            continue;
        }
        for (const [xField, yField] of state.targetFields) {
            if (xField in target || yField in target) {
                target.x = target[xField];
                target.y = target[yField];
                break;
            }
        }
        state.options.targets.push(target);
    }
    snap.set(arg);
    state.options = options;
}
const defaults = {
    range: Infinity,
    targets: null,
    offset: null,
    endOnly: false,
    enabled: false,
};
const snapSize = {
    start,
    set,
    defaults,
};
export default snapSize;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2l6ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInNpemUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsbUVBQW1FO0FBQ25FLGdCQUFnQjtBQUVoQixPQUFPLE1BQU0sTUFBTSwwQkFBMEIsQ0FBQTtBQUM3QyxPQUFPLEtBQUssRUFBRSxNQUFNLHNCQUFzQixDQUFBO0FBQzFDLE9BQU8sSUFBcUIsTUFBTSxXQUFXLENBQUE7QUFPN0MsU0FBUyxLQUFLLENBQUUsR0FBRztJQUNqQixNQUFNLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRSxHQUFHLEdBQUcsQ0FBQTtJQUNsQyxNQUFNLEVBQUUsT0FBTyxFQUFFLEdBQUcsS0FBSyxDQUFBO0lBQ3pCLE1BQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFBO0lBRXhDLElBQUksQ0FBQyxLQUFLLEVBQUU7UUFBRSxPQUFPLElBQUksQ0FBQTtLQUFFO0lBRTNCLEdBQUcsQ0FBQyxLQUFLLEdBQUc7UUFDVixPQUFPLEVBQUU7WUFDUCxjQUFjLEVBQUUsQ0FBQztvQkFDZixDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUNyQixDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUNyQixDQUFDO1lBQ0YsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFO1lBQ3RCLE1BQU0sRUFBRSxPQUFPLENBQUMsTUFBTSxJQUFJLE1BQU07WUFDaEMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLO1NBQ3JCO0tBQ0YsQ0FBQTtJQUVELEtBQUssQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDLFlBQVksSUFBSTtRQUN6QyxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUM7UUFDbkIsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDO0tBQ1gsQ0FBQTtJQUVELElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUE7SUFDZixLQUFLLENBQUMsT0FBTyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFBO0lBRWpDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFBO0FBQ25CLENBQUM7QUFFRCxTQUFTLEdBQUcsQ0FBRSxHQUFHO0lBQ2YsTUFBTSxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFBO0lBQzFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLEdBQUcsS0FBSyxDQUFBO0lBQ2xDLE1BQU0sUUFBUSxHQUFHO1FBQ2YsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUIsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDM0IsQ0FBQTtJQUVELEtBQUssQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQTtJQUNuQyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUE7SUFFMUIsS0FBSyxNQUFNLFVBQVUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDLEVBQUU7UUFDaEQsSUFBSSxNQUFNLENBQUE7UUFFVixJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDdkIsTUFBTSxHQUFHLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUE7U0FDekQ7YUFDSTtZQUNILE1BQU0sR0FBRyxVQUFVLENBQUE7U0FDcEI7UUFFRCxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQUUsU0FBUTtTQUFFO1FBRXpCLEtBQUssTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsWUFBWSxFQUFFO1lBQ2pELElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxFQUFFO2dCQUN4QyxNQUFNLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQTtnQkFDekIsTUFBTSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUE7Z0JBRXpCLE1BQUs7YUFDTjtTQUNGO1FBRUQsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO0tBQ25DO0lBRUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQTtJQUViLEtBQUssQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFBO0FBQ3pCLENBQUM7QUFFRCxNQUFNLFFBQVEsR0FBb0I7SUFDaEMsS0FBSyxFQUFFLFFBQVE7SUFDZixPQUFPLEVBQUUsSUFBSTtJQUNiLE1BQU0sRUFBRSxJQUFJO0lBQ1osT0FBTyxFQUFFLEtBQUs7SUFDZCxPQUFPLEVBQUUsS0FBSztDQUNmLENBQUE7QUFFRCxNQUFNLFFBQVEsR0FBRztJQUNmLEtBQUs7SUFDTCxHQUFHO0lBQ0gsUUFBUTtDQUNULENBQUE7QUFFRCxlQUFlLFFBQVEsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgbW9kdWxlIGFsbG93cyBzbmFwcGluZyBvZiB0aGUgc2l6ZSBvZiB0YXJnZXRzIGR1cmluZyByZXNpemVcbi8vIGludGVyYWN0aW9ucy5cblxuaW1wb3J0IGV4dGVuZCBmcm9tICdAaW50ZXJhY3Rqcy91dGlscy9leHRlbmQnXG5pbXBvcnQgKiBhcyBpcyBmcm9tICdAaW50ZXJhY3Rqcy91dGlscy9pcydcbmltcG9ydCBzbmFwLCB7IFNuYXBPcHRpb25zIH0gZnJvbSAnLi9wb2ludGVyJ1xuXG5leHBvcnQgdHlwZSBTbmFwU2l6ZU9wdGlvbnMgPSBQaWNrPFxuICBTbmFwT3B0aW9ucyxcbiAgJ3RhcmdldHMnIHwgJ29mZnNldCcgfCAnZW5kT25seScgfCAnZW5hYmxlZCcgfCAncmFuZ2UnXG4+XG5cbmZ1bmN0aW9uIHN0YXJ0IChhcmcpIHtcbiAgY29uc3QgeyBpbnRlcmFjdGlvbiwgc3RhdGUgfSA9IGFyZ1xuICBjb25zdCB7IG9wdGlvbnMgfSA9IHN0YXRlXG4gIGNvbnN0IGVkZ2VzID0gaW50ZXJhY3Rpb24ucHJlcGFyZWQuZWRnZXNcblxuICBpZiAoIWVkZ2VzKSB7IHJldHVybiBudWxsIH1cblxuICBhcmcuc3RhdGUgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgcmVsYXRpdmVQb2ludHM6IFt7XG4gICAgICAgIHg6IGVkZ2VzLmxlZnQgPyAwIDogMSxcbiAgICAgICAgeTogZWRnZXMudG9wID8gMCA6IDEsXG4gICAgICB9XSxcbiAgICAgIG9yaWdpbjogeyB4OiAwLCB5OiAwIH0sXG4gICAgICBvZmZzZXQ6IG9wdGlvbnMub2Zmc2V0IHx8ICdzZWxmJyxcbiAgICAgIHJhbmdlOiBvcHRpb25zLnJhbmdlLFxuICAgIH0sXG4gIH1cblxuICBzdGF0ZS50YXJnZXRGaWVsZHMgPSBzdGF0ZS50YXJnZXRGaWVsZHMgfHwgW1xuICAgIFsnd2lkdGgnLCAnaGVpZ2h0J10sXG4gICAgWyd4JywgJ3knXSxcbiAgXVxuXG4gIHNuYXAuc3RhcnQoYXJnKVxuICBzdGF0ZS5vZmZzZXRzID0gYXJnLnN0YXRlLm9mZnNldHNcblxuICBhcmcuc3RhdGUgPSBzdGF0ZVxufVxuXG5mdW5jdGlvbiBzZXQgKGFyZykge1xuICBjb25zdCB7IGludGVyYWN0aW9uLCBzdGF0ZSwgY29vcmRzIH0gPSBhcmdcbiAgY29uc3QgeyBvcHRpb25zLCBvZmZzZXRzIH0gPSBzdGF0ZVxuICBjb25zdCByZWxhdGl2ZSA9IHtcbiAgICB4OiBjb29yZHMueCAtIG9mZnNldHNbMF0ueCxcbiAgICB5OiBjb29yZHMueSAtIG9mZnNldHNbMF0ueSxcbiAgfVxuXG4gIHN0YXRlLm9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpXG4gIHN0YXRlLm9wdGlvbnMudGFyZ2V0cyA9IFtdXG5cbiAgZm9yIChjb25zdCBzbmFwVGFyZ2V0IG9mIChvcHRpb25zLnRhcmdldHMgfHwgW10pKSB7XG4gICAgbGV0IHRhcmdldFxuXG4gICAgaWYgKGlzLmZ1bmMoc25hcFRhcmdldCkpIHtcbiAgICAgIHRhcmdldCA9IHNuYXBUYXJnZXQocmVsYXRpdmUueCwgcmVsYXRpdmUueSwgaW50ZXJhY3Rpb24pXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGFyZ2V0ID0gc25hcFRhcmdldFxuICAgIH1cblxuICAgIGlmICghdGFyZ2V0KSB7IGNvbnRpbnVlIH1cblxuICAgIGZvciAoY29uc3QgW3hGaWVsZCwgeUZpZWxkXSBvZiBzdGF0ZS50YXJnZXRGaWVsZHMpIHtcbiAgICAgIGlmICh4RmllbGQgaW4gdGFyZ2V0IHx8IHlGaWVsZCBpbiB0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0LnggPSB0YXJnZXRbeEZpZWxkXVxuICAgICAgICB0YXJnZXQueSA9IHRhcmdldFt5RmllbGRdXG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5vcHRpb25zLnRhcmdldHMucHVzaCh0YXJnZXQpXG4gIH1cblxuICBzbmFwLnNldChhcmcpXG5cbiAgc3RhdGUub3B0aW9ucyA9IG9wdGlvbnNcbn1cblxuY29uc3QgZGVmYXVsdHM6IFNuYXBTaXplT3B0aW9ucyA9IHtcbiAgcmFuZ2U6IEluZmluaXR5LFxuICB0YXJnZXRzOiBudWxsLFxuICBvZmZzZXQ6IG51bGwsXG4gIGVuZE9ubHk6IGZhbHNlLFxuICBlbmFibGVkOiBmYWxzZSxcbn1cblxuY29uc3Qgc25hcFNpemUgPSB7XG4gIHN0YXJ0LFxuICBzZXQsXG4gIGRlZmF1bHRzLFxufVxuXG5leHBvcnQgZGVmYXVsdCBzbmFwU2l6ZVxuIl19