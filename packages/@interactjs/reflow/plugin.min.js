import{Interactable as e}from"../core/Interactable.min.js";import{Interaction as t}from"../core/Interaction.min.js";import*as o from"../utils/arr.min.js";import r from"../utils/is.min.js";import{copyAction as n}from"../utils/misc.min.js";import*as i from"../utils/pointerUtils.min.js";import{tlbrToXywh as s}from"../utils/rect.min.js";export function install(e){const{Interactable:t}=e;e.actions.phases.reflow=!0,t.prototype.reflow=function(t){return function(e,t,n){const a=r.string(e.target)?o.from(e._context.querySelectorAll(e.target)):[e.target],m=n.window.Promise,c=m?[]:null;for(const r of a){const a=e.getRect(r);if(!a)break;const f=o.find(n.interactions.list,o=>o.interacting()&&o.interactable===e&&o.element===r&&o.prepared.name===t.name);let p;if(f)f.move(),c&&(p=f._reflowPromise||new m(e=>{f._reflowResolve=e}));else{const o=s(a),m={page:{x:o.x,y:o.y},client:{x:o.x,y:o.y},timeStamp:n.now()},c=i.coordsToEvent(m);p=l(n,e,r,t,c)}c&&c.push(p)}return c&&m.all(c).then(()=>e)}(this,t,e)}}function l(e,t,o,r,s){const l=e.interactions.new({pointerType:"reflow"}),a={interaction:l,event:s,pointer:s,eventTarget:o,phase:"reflow"};l.interactable=t,l.element=o,l.prevEvent=s,l.updatePointer(s,s,o,!0),i.setZeroCoords(l.coords.delta),n(l.prepared,r),l._doPhase(a);const{Promise:m}=e.window,c=m?new m(e=>{l._reflowResolve=e}):void 0;return l._reflowPromise=c,l.start(r,t,o),l._interacting?(l.move(a),l.end(s)):(l.stop(),l._reflowResolve()),l.removePointer(s,s),c}export default{id:"reflow",install:install,listeners:{"interactions:stop"({interaction:e},t){"reflow"===e.pointerType&&(e._reflowResolve&&e._reflowResolve(),o.remove(t.interactions.list,e))}}};
//# sourceMappingURL=plugin.min.js.map