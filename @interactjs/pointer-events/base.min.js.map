{
	"version": 3,
	"sources": [
		"base.ts"
	],
	"names": [
		"Interaction",
		"Scope",
		"utils",
		"PointerEvent",
		"pointerEvents",
		"id",
		"install",
		"scope",
		"defaults",
		"actions",
		"extend",
		"phaselessTypes",
		"types",
		"listeners",
		"interactions:new",
		"interaction",
		"prevTap",
		"tapTime",
		"interactions:update-pointer",
		"down",
		"pointerInfo",
		"hold",
		"duration",
		"Infinity",
		"timeout",
		"interactions:move",
		"pointer",
		"event",
		"eventTarget",
		"duplicate",
		"pointerIndex",
		"getPointerIndex",
		"pointerIsDown",
		"pointerWasMoved",
		"clearTimeout",
		"pointers",
		"fire",
		"type",
		"interactions:down",
		"arg",
		"timer",
		"path",
		"dom",
		"getPath",
		"signalArg",
		"targets",
		"node",
		"length",
		"minDuration",
		"target",
		"holdDuration",
		"eventable",
		"options",
		"setTimeout",
		"downAndStartHold",
		"interactions:up",
		"clearHold",
		"tapAfterUp",
		"interactions:cancel",
		"collectEventTargets",
		"ignoreFrom",
		"allowFrom",
		"origin",
		"x",
		"y",
		"move",
		"up",
		"cancel",
		"tap",
		"doubletap",
		"pointerEvent",
		"now",
		"i",
		"prop",
		"props",
		"getOriginXY",
		"_subtractOrigin",
		"currentTarget",
		"_addOrigin",
		"immediatePropagationStopped",
		"propagationStopped",
		"double",
		"timeStamp",
		"downTarget",
		"filter"
	],
	"mappings": "OAEOA,MAAiB,6CACfC,MAAa,iCACVC,MAAW,+BAChBC,MAAkB,sBAqEzB,MAOMC,EAAgB,CACpBC,GAAI,sBACJC,QAuPF,SAAkBC,GAChBA,EAAMH,cAAgBA,EACtBG,EAAMC,SAASC,QAAQL,cAAgBA,EAAcI,SACrDN,EAAMQ,OAAOH,EAAME,QAAQE,eAAgBP,EAAcQ,QAzPzDC,UAAW,CACTC,mBA2JJ,UAA8BC,YAAEA,IAC9BA,EAAYC,QAAU,KACtBD,EAAYE,QAAU,GA5JpBC,8BA+JJ,UAAsBC,KAAEA,EAAFC,YAAQA,IAC5B,IAAKD,GAAQC,EAAYC,KACvB,OAGFD,EAAYC,KAAO,CAAEC,SAAUC,EAAAA,EAAUC,QAAS,OAnKhDC,oBA4KJ,UACEV,YAAEA,EAAFW,QAAeA,EAAfC,MAAwBA,EAAxBC,YAA+BA,EAA/BC,UAA4CA,GAC5CtB,GAEA,MAAMuB,EAAef,EAAYgB,gBAAgBL,GAE5CG,GAAed,EAAYiB,gBAAiBjB,EAAYkB,kBACvDlB,EAAYiB,eACdE,aAAanB,EAAYoB,SAASL,GAAcT,KAAKG,SAGvDY,EAAK,CACHrB,YAAAA,EACAW,QAAAA,EACAC,MAAAA,EACAC,YAAaA,EACbS,KAAM,QACL9B,KA5LH+B,oBAAqB,CAACC,EAAKhC,MAgM/B,UAA2BQ,YAAEA,EAAFW,QAAeA,EAAfC,MAAwBA,EAAxBC,YAA+BA,EAA/BE,aAA4CA,GAA0DvB,GAC/H,MAAMiC,EAAQzB,EAAYoB,SAASL,GAAcT,KAC3CoB,EAAOvC,EAAMwC,IAAIC,QAAQf,GACzBgB,EAAY,CAChB7B,YAAAA,EACAW,QAAAA,EACAC,MAAAA,EACAC,YAAAA,EACAS,KAAM,OACNQ,QAAS,GACTJ,KAAAA,EACAK,KAAM,MAGR,IAAK,MAAMA,KAAQL,EACjBG,EAAUE,KAAOA,EAEjBvC,EAAM6B,KAAK,gCAAiCQ,GAG9C,IAAKA,EAAUC,QAAQE,OAAU,OAEjC,IAAIC,EAAczB,EAAAA,EAElB,IAAK,MAAM0B,KAAUL,EAAUC,QAAS,CACtC,MAAMK,EAAeD,EAAOE,UAAUC,QAAQF,aAE1CA,EAAeF,IACjBA,EAAcE,GAIlBV,EAAMlB,SAAW0B,EACjBR,EAAMhB,QAAU6B,WAAW,KACzBjB,EAAK,CACHrB,YAAAA,EACAa,YAAAA,EACAF,QAAAA,EACAC,MAAAA,EACAU,KAAM,QACL9B,IACFyC,GAxOCM,CAAiBf,EAAKhC,GACtB6B,EAAKG,EAAKhC,IAEZgD,kBAAmB,CAAChB,EAAKhC,KACvBiD,EAAUjB,GACVH,EAAKG,EAAKhC,GAsOhB,UAAqBQ,YAAEA,EAAFW,QAAeA,EAAfC,MAAwBA,EAAxBC,YAA+BA,GAAuDrB,GACpGQ,EAAYkB,iBACfG,EAAK,CAAErB,YAAAA,EAAaa,YAAAA,EAAaF,QAAAA,EAASC,MAAAA,EAAOU,KAAM,OAAS9B,GAvO9DkD,CAAWlB,EAAKhC,IAElBmD,sBAAuB,CAACnB,EAAKhC,KAC3BiD,EAAUjB,GACVH,EAAKG,EAAKhC,KAGdJ,aAAAA,EACAiC,KAAAA,EACAuB,oBAAAA,EACAnD,SA/BoC,CACpC0C,aAAc,IACdU,WAAc,KACdC,UAAc,KACdC,OAAc,CAAEC,EAAG,EAAGC,EAAG,IA4BzBpD,MAAO,CACLO,MAAM,EACN8C,MAAM,EACNC,IAAI,EACJC,QAAQ,EACRC,KAAK,EACLC,WAAW,EACXhD,MAAM,IAIV,SAASe,EACPG,EAQAhC,GAEA,MAAMQ,YACJA,EADIW,QAEJA,EAFIC,MAGJA,EAHIC,YAIJA,EAJIS,KAKJA,EALIQ,QAMJA,EAAUc,EAAoBpB,EAAKhC,IACjCgC,EAEE+B,EAAe,IAAInE,EAAakC,EAAMX,EAASC,EAAOC,EAAab,EAAaR,EAAMgE,OAE5FhE,EAAM6B,KAAK,oBAAqB,CAAEkC,aAAAA,IAElC,MAAM1B,EAAY,CAChB7B,YAAAA,EACAW,QAAAA,EACAC,MAAAA,EACAC,YAAAA,EACAiB,QAAAA,EACAR,KAAAA,EACAiC,aAAAA,GAGF,IAAK,IAAIE,EAAI,EAAGA,EAAI3B,EAAQE,OAAQyB,IAAK,CACvC,MAAMvB,EAASJ,EAAQ2B,GAEvB,IAAK,MAAMC,KAAQxB,EAAOyB,OAAS,GAChCJ,EAAqBG,GAAQxB,EAAOyB,MAAMD,GAG7C,MAAMX,EAAS5D,EAAMyE,YAAY1B,EAAOE,UAAWF,EAAOH,MAU1D,GARAwB,EAAaM,gBAAgBd,GAC7BQ,EAAanB,UAAYF,EAAOE,UAChCmB,EAAaO,cAAgB5B,EAAOH,KAEpCG,EAAOE,UAAUf,KAAKkC,GAEtBA,EAAaQ,WAAWhB,GAEpBQ,EAAaS,6BACZT,EAAaU,oBACTR,EAAI,EAAK3B,EAAQE,QAAUF,EAAQ2B,EAAI,GAAG1B,OAASwB,EAAaO,cACvE,MAMJ,GAFAtE,EAAM6B,KAAK,sBAAuBQ,GAErB,QAATP,EAAgB,CAGlB,MAAMrB,EAAUsD,EAAaW,OACzB7C,EAAK,CACLrB,YAAAA,EACAW,QAAAA,EACAC,MAAAA,EACAC,YAAAA,EACAS,KAAM,aACL9B,GACD+D,EAEJvD,EAAYC,QAAUA,EACtBD,EAAYE,QAAUD,EAAQkE,UAGhC,OAAOZ,EAGT,SAASX,GAAuC5C,YAAEA,EAAFW,QAAeA,EAAfC,MAAwBA,EAAxBC,YAA+BA,EAA/BS,KAA4CA,GAMzF9B,GACD,MAAMuB,EAAef,EAAYgB,gBAAgBL,GAC3CN,EAAcL,EAAYoB,SAASL,GAGzC,GAAa,QAATO,IAAmBtB,EAAYkB,kBAE7Bb,GAAeA,EAAY+D,aAAevD,GAC9C,MAAO,GAGT,MAAMa,EAAOvC,EAAMwC,IAAIC,QAAQf,GACzBgB,EAAY,CAChB7B,YAAAA,EACAW,QAAAA,EACAC,MAAAA,EACAC,YAAAA,EACAS,KAAAA,EACAI,KAAAA,EACAI,QAAS,GACTC,KAAM,MAGR,IAAK,MAAMA,KAAQL,EACjBG,EAAUE,KAAOA,EAEjBvC,EAAM6B,KAAK,gCAAiCQ,GAQ9C,MALa,SAATP,IACFO,EAAUC,QAAUD,EAAUC,QAAQuC,OAAOnC,GAC3CA,EAAOE,UAAUC,QAAQF,eAAiBnC,EAAYoB,SAASL,GAAcT,KAAKC,WAG/EsB,EAAUC,QAgBnB,SAASW,GAAWzC,YAAEA,EAAFe,aAAeA,IAC7Bf,EAAYoB,SAASL,GAAcT,MACrCa,aAAanB,EAAYoB,SAASL,GAAcT,KAAKG,wBAiF1CpB",
	"sourcesContent": [
		"import { PerActionDefaults } from '@interactjs/core/defaultOptions'\nimport Eventable from '@interactjs/core/Eventable'\nimport Interaction from '@interactjs/core/Interaction'\nimport { Scope } from '@interactjs/core/scope'\nimport * as utils from '@interactjs/utils/index'\nimport PointerEvent from './PointerEvent'\n\nexport type EventTargetList = Array<{\n  node: Node\n  eventable: Eventable\n  props: { [key: string]: any }\n}>\n\nexport interface PointerEventOptions extends PerActionDefaults {\n  enabled?: undefined // not used\n  holdDuration?: number\n  ignoreFrom?: any\n  allowFrom?: any\n  origin?: Interact.Point | string | Interact.Element\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    pointerEvents: typeof pointerEvents\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    prevTap?: PointerEvent<string>\n    tapTime?: number\n  }\n}\n\ndeclare module '@interactjs/core/PointerInfo' {\n  interface PointerInfo {\n    hold?: {\n      duration: number\n      timeout: any\n    }\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface ActionDefaults {\n    pointerEvents: Interact.Options\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'pointerEvents:new': { pointerEvent: PointerEvent<any> }\n    'pointerEvents:fired': {\n      interaction: Interaction\n      pointer: Interact.PointerType | PointerEvent<any>\n      event: Interact.PointerEventType | PointerEvent<any>\n      eventTarget: Interact.EventTarget\n      pointerEvent: PointerEvent<any>\n      targets?: EventTargetList\n      type: string\n    }\n    'pointerEvents:collect-targets': {\n      interaction: Interaction\n      pointer: Interact.PointerType | PointerEvent<any>\n      event: Interact.PointerEventType | PointerEvent<any>\n      eventTarget: Interact.EventTarget\n      targets?: EventTargetList\n      type: string\n      path: Node[]\n      node: null\n    }\n  }\n}\n\nconst defaults: PointerEventOptions = {\n  holdDuration: 600,\n  ignoreFrom  : null,\n  allowFrom   : null,\n  origin      : { x: 0, y: 0 },\n}\n\nconst pointerEvents = {\n  id: 'pointer-events/base',\n  install,\n  listeners: {\n    'interactions:new': addInteractionProps,\n    'interactions:update-pointer': addHoldInfo,\n    'interactions:move': moveAndClearHold,\n    'interactions:down': (arg, scope) => {\n      downAndStartHold(arg, scope)\n      fire(arg, scope)\n    },\n    'interactions:up': (arg, scope) => {\n      clearHold(arg)\n      fire(arg, scope)\n      tapAfterUp(arg, scope)\n    },\n    'interactions:cancel': (arg, scope) => {\n      clearHold(arg)\n      fire(arg, scope)\n    },\n  },\n  PointerEvent,\n  fire,\n  collectEventTargets,\n  defaults,\n  types: {\n    down: true,\n    move: true,\n    up: true,\n    cancel: true,\n    tap: true,\n    doubletap: true,\n    hold: true,\n  } as { [type: string]: true },\n}\n\nfunction fire<T extends string> (\n  arg: {\n    pointer: Interact.PointerType | PointerEvent<any>\n    event: Interact.PointerEventType | PointerEvent<any>\n    eventTarget: Interact.EventTarget\n    interaction: Interaction\n    type: T\n    targets?: EventTargetList\n  },\n  scope: Interact.Scope,\n) {\n  const {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n    targets = collectEventTargets(arg, scope),\n  } = arg\n\n  const pointerEvent = new PointerEvent(type, pointer, event, eventTarget, interaction, scope.now())\n\n  scope.fire('pointerEvents:new', { pointerEvent })\n\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    targets,\n    type,\n    pointerEvent,\n  }\n\n  for (let i = 0; i < targets.length; i++) {\n    const target = targets[i]\n\n    for (const prop in target.props || {}) {\n      (pointerEvent as any)[prop] = target.props[prop]\n    }\n\n    const origin = utils.getOriginXY(target.eventable, target.node)\n\n    pointerEvent._subtractOrigin(origin)\n    pointerEvent.eventable = target.eventable\n    pointerEvent.currentTarget = target.node\n\n    target.eventable.fire(pointerEvent)\n\n    pointerEvent._addOrigin(origin)\n\n    if (pointerEvent.immediatePropagationStopped ||\n        (pointerEvent.propagationStopped &&\n            (i + 1) < targets.length && targets[i + 1].node !== pointerEvent.currentTarget)) {\n      break\n    }\n  }\n\n  scope.fire('pointerEvents:fired', signalArg)\n\n  if (type === 'tap') {\n    // if pointerEvent should make a double tap, create and fire a doubletap\n    // PointerEvent and use that as the prevTap\n    const prevTap = pointerEvent.double\n      ? fire({\n        interaction,\n        pointer,\n        event,\n        eventTarget,\n        type: 'doubletap',\n      }, scope)\n      : pointerEvent\n\n    interaction.prevTap = prevTap\n    interaction.tapTime = prevTap.timeStamp\n  }\n\n  return pointerEvent\n}\n\nfunction collectEventTargets<T extends string> ({ interaction, pointer, event, eventTarget, type }: {\n  interaction: Interaction\n  pointer: Interact.PointerType | PointerEvent<any>\n  event: Interact.PointerEventType | PointerEvent<any>\n  eventTarget: Interact.EventTarget\n  type: T\n}, scope: Interact.Scope) {\n  const pointerIndex = interaction.getPointerIndex(pointer)\n  const pointerInfo = interaction.pointers[pointerIndex]\n\n  // do not fire a tap event if the pointer was moved before being lifted\n  if (type === 'tap' && (interaction.pointerWasMoved ||\n      // or if the pointerup target is different to the pointerdown target\n      !(pointerInfo && pointerInfo.downTarget === eventTarget))) {\n    return []\n  }\n\n  const path = utils.dom.getPath(eventTarget as Interact.Element | Document)\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n    path,\n    targets: [] as EventTargetList,\n    node: null,\n  }\n\n  for (const node of path) {\n    signalArg.node = node\n\n    scope.fire('pointerEvents:collect-targets', signalArg)\n  }\n\n  if (type === 'hold') {\n    signalArg.targets = signalArg.targets.filter(target =>\n      target.eventable.options.holdDuration === interaction.pointers[pointerIndex].hold.duration)\n  }\n\n  return signalArg.targets\n}\n\nfunction addInteractionProps ({ interaction }) {\n  interaction.prevTap = null   // the most recent tap event on this interaction\n  interaction.tapTime = 0     // time of the most recent tap event\n}\n\nfunction addHoldInfo ({ down, pointerInfo }: Interact.SignalArgs['interactions:update-pointer']) {\n  if (!down && pointerInfo.hold) {\n    return\n  }\n\n  pointerInfo.hold = { duration: Infinity, timeout: null }\n}\n\nfunction clearHold ({ interaction, pointerIndex }) {\n  if (interaction.pointers[pointerIndex].hold) {\n    clearTimeout(interaction.pointers[pointerIndex].hold.timeout)\n  }\n}\n\nfunction moveAndClearHold (\n  { interaction, pointer, event, eventTarget, duplicate }: Interact.SignalArgs['interactions:move'],\n  scope: Interact.Scope,\n) {\n  const pointerIndex = interaction.getPointerIndex(pointer)\n\n  if (!duplicate && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n    if (interaction.pointerIsDown) {\n      clearTimeout(interaction.pointers[pointerIndex].hold.timeout)\n    }\n\n    fire({\n      interaction,\n      pointer,\n      event,\n      eventTarget: eventTarget as Interact.Element,\n      type: 'move',\n    }, scope)\n  }\n}\n\nfunction downAndStartHold ({ interaction, pointer, event, eventTarget, pointerIndex }: Interact.SignalArgs['interactions:down'], scope: Interact.Scope) {\n  const timer = interaction.pointers[pointerIndex].hold\n  const path = utils.dom.getPath(eventTarget as Interact.Element | Document)\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type: 'hold',\n    targets: [] as EventTargetList,\n    path,\n    node: null,\n  }\n\n  for (const node of path) {\n    signalArg.node = node\n\n    scope.fire('pointerEvents:collect-targets', signalArg)\n  }\n\n  if (!signalArg.targets.length) { return }\n\n  let minDuration = Infinity\n\n  for (const target of signalArg.targets) {\n    const holdDuration = target.eventable.options.holdDuration\n\n    if (holdDuration < minDuration) {\n      minDuration = holdDuration\n    }\n  }\n\n  timer.duration = minDuration\n  timer.timeout = setTimeout(() => {\n    fire({\n      interaction,\n      eventTarget,\n      pointer,\n      event,\n      type: 'hold',\n    }, scope)\n  }, minDuration)\n}\n\nfunction tapAfterUp ({ interaction, pointer, event, eventTarget }: Interact.SignalArgs['interactions:up'], scope: Interact.Scope) {\n  if (!interaction.pointerWasMoved) {\n    fire({ interaction, eventTarget, pointer, event, type: 'tap' }, scope)\n  }\n}\n\nfunction install (scope: Scope) {\n  scope.pointerEvents = pointerEvents\n  scope.defaults.actions.pointerEvents = pointerEvents.defaults\n  utils.extend(scope.actions.phaselessTypes, pointerEvents.types)\n}\n\nexport default pointerEvents\n"
	]
}